# Implementation Plan: Production-Ready Platform Evolution

**Branch**: `002-production-ready` | **Date**: 2025-11-30 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/002-production-ready/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command following the workflow in `.specify/templates/commands/plan.md`.

## Summary

Evolve Chat4All v2 from a functional prototype into a production-ready, distributed messaging platform capable of supporting millions of users with 99.95% availability. The implementation focuses on establishing reliability guarantees (at-least-once delivery via Transactional Outbox), real-time communication (WebSocket with Redis Pub/Sub), fault-tolerant infrastructure (PostgreSQL HA, Kafka clusters, Kubernetes auto-scaling), secure authentication (OAuth 2.0 Client Credentials with JWT), resumable file uploads (chunked uploads up to 2GB), enhanced API functionality (conversation listing, read receipts, rate limiting), and production-grade observability (Prometheus, OpenTelemetry, ELK/Loki). The technical approach prioritizes stability and core infrastructure first (Phases 1-2), followed by user-facing features (Phase 3), and operational enhancements (Phases 4-5).

## Technical Context

**Language/Version**: Python 3.11+  
**Primary Dependencies**: 
- FastAPI 0.104.1 (REST API)
- python-grpc/grpcio 1.59+ (internal service-to-service RPC)
- SQLAlchemy 2.0.23 (ORM)
- Kafka-Python 2.0.2 or aiokafka (message broker client)
- Redis-py 5.0+ (Pub/Sub, caching, rate limiting)
- python-jose or authlib (JWT token handling for OAuth 2.0)
- websockets or FastAPI WebSocket support (real-time communication)
- boto3 or minio-py (S3/MinIO client for file storage)
- Prometheus-client (metrics)
- OpenTelemetry Python SDK (distributed tracing)

**Storage**: 
- PostgreSQL 15+ with Patroni/Stolon for HA (primary + 2 replicas, 30s failover)
- Redis 7+ (session store, rate limiting, WebSocket fan-out, deduplication cache)
- Apache Kafka 3.5+ (message broker with 3-broker cluster, RF=3, min.insync.replicas=2)
- MinIO 7.2.0 or AWS S3 (file attachments up to 2GB)

**Testing**: 
- pytest 7.4.3 (unit, integration, e2e tests)
- pytest-asyncio (async test support)
- testcontainers-python (integration tests with real PostgreSQL/Kafka/Redis)
- locust or k6 (load testing for 10M msg/min validation)
- chaos toolkit (chaos engineering experiments)

**Target Platform**: 
- Kubernetes 1.28+ (primary deployment target)
- Docker Compose (local development)
- Linux containers (all services containerized)

**Project Type**: Distributed web platform (REST + gRPC + WebSocket APIs, async workers, stateless services)

**Performance Goals**: 
- API ingestion to Kafka persistence: <200ms p99 latency
- Message throughput: 10 million messages/minute (peak)
- Database query latency: <50ms p95
- WebSocket notification delivery: <100ms from message ingestion
- Concurrent WebSocket connections: 10,000 per API instance
- File upload throughput: Support 2GB files with 5-10MB chunks

**Constraints**: 
- Availability: ≥99.95% SLA (max 4.38 hours downtime/year)
- At-least-once message delivery guarantee (no silent message loss)
- Causal ordering within conversations (partition by conversation_id)
- Maximum file size: 2GB (enforced by API validation)
- Rate limiting: 60 requests/minute per user (adjustable)
- Idempotency: 24-hour deduplication window for messages
- TLS 1.3 mandatory for all external communication
- OAuth 2.0 Client Credentials for authentication (JWT with 15min expiration)

**Scale/Scope**: 
- Expected users: Millions of concurrent users
- Expected conversations: Millions of active conversations
- Expected messages: Billions of messages stored, 10M/min peak ingestion
- Expected files: Hundreds of thousands of file uploads (up to 2GB each)
- Expected WebSocket connections: Tens of thousands per API instance, millions globally
- System components: 10+ microservices (API gateway, workers per channel, routers, merge workers, outbox pollers)
- Deployment: Multi-region Kubernetes clusters (future), single-region initially

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Principle I - Ubiquity and Interoperability**:
- [x] Does this feature maintain API contract stability across channels? YES - OAuth 2.0 and WebSocket additions are channel-agnostic
- [x] Are channel-specific details properly abstracted? YES - Mock connectors validate architecture without channel specifics
- [x] Can new channels integrate without breaking changes? YES - Connector plugin architecture unchanged

**Principle II - Reliability and Resilience**:
- [x] Does this feature guarantee at-least-once message delivery? YES - Epic 2: Transactional Outbox pattern (FR-DP-01 to FR-DP-10)
- [x] Are all operations idempotent? YES - FR-DP-04: database constraints, FR-DP-09: UNIQUE on message.id
- [x] Is failure recovery explicitly designed (circuit breakers, retries)? YES - FR-DP-05: exponential backoff, FR-DP-06: DLQ for poison messages
- [x] Does this maintain ≥99.95% availability SLA? YES - Epic 3: PostgreSQL HA (FR-HA-01 to FR-HA-09), Kafka clustering, K8s auto-scaling

**Principle III - Scalability and Performance**:
- [x] Can this scale horizontally (stateless services)? YES - FR-HA-05: 3+ replicas, FR-HA-07: HPA auto-scaling
- [x] Are performance targets met (<200ms p99 API latency)? YES - NFR-PERF-02: <200ms p99 API latency, NFR-PERF-05: <50ms p95 DB queries
- [x] Does database design support required throughput (10M msg/min)? YES - NFR-PERF-01: 10M msg/min, FR-DP-08: partition by conversation_id
- [x] Is load shedding/graceful degradation considered? YES - NFR-SCAL-03: graceful degradation under overload

**Principle IV - Consistency and Order**:
- [x] Is causal message ordering preserved within conversations? YES - FR-DP-08: Kafka partition key = conversation_id
- [x] Are idempotency keys used for deduplication? YES - FR-DP-04: message.id as idempotency key, FR-DP-09: UNIQUE constraint
- [x] Is conflict resolution for eventual consistency defined? YES - NFR-CONS-02: strong eventual consistency with CRDTs/vector clocks

**Principle V - Extensibility and Maintainability**:
- [x] Is architecture modular (core platform vs connectors)? YES - Existing hexagonal architecture maintained
- [x] Are interfaces well-defined for new channel integrations? YES - IConnector interface unchanged
- [x] Is clean architecture followed (dependency inversion)? YES - No architectural changes to core/domain separation
- [x] Is documentation complete (architecture diagrams, API specs, runbooks)? YES - Phase 1 generates contracts/, quickstart.md, data-model.md

**Principle VI - Security and Privacy**:
- [x] Is TLS 1.3+ enforced for all communication? YES - NFR-SEC-01: TLS 1.3 mandatory
- [x] Is authentication/authorization implemented (OAuth 2.0)? YES - Epic 0: OAuth 2.0 Client Credentials (FR-AUTH-01 to FR-AUTH-10)
- [x] Are passwords hashed with bcrypt/Argon2? YES - NFR-SEC-02: bcrypt cost ≥12
- [x] Is rate limiting enforced (per-user and global)? YES - FR-API-04: 60 req/min per user
- [x] Is input validation comprehensive (Pydantic/Protobuf)? YES - NFR-SEC-04: Pydantic for REST, Protobuf for gRPC
- [x] Is audit logging implemented for security events? YES - NFR-SEC-05: audit logs for auth failures, privilege escalations

**Principle VII - Observability**:
- [x] Are Prometheus metrics exposed for all services? YES - FR-OBS-01: Prometheus metrics for all services
- [x] Is OpenTelemetry tracing implemented across service boundaries? YES - FR-OBS-03: OpenTelemetry distributed tracing
- [x] Are structured logs (JSON) with correlation IDs used? YES - FR-OBS-05: JSON logs with trace_id correlation
- [x] Are health check endpoints (/health, /ready) exposed? YES - FR-OBS-08: health/readiness endpoints
- [x] Are dashboards and alerts configured for SLA monitoring? YES - FR-OBS-06: Grafana dashboards, FR-OBS-10: Alertmanager integration

**CONSTITUTION GATE STATUS**: ✅ **PASSED** - All 7 principles satisfied, no violations requiring justification

## Project Structure

### Documentation (this feature)

```text
specs/002-production-ready/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output - OAuth 2.0 library evaluation, outbox patterns, WebSocket scaling
├── data-model.md        # Phase 1 output - access_tokens, refresh_tokens, outbox_events, file_uploads, websocket_connections
├── quickstart.md        # Phase 1 output - OAuth 2.0 setup, WebSocket examples, production deployment
├── contracts/           # Phase 1 output - OpenAPI specs for authentication, WebSocket protocol, file upload
│   ├── authentication-api.yaml
│   ├── websocket-protocol.md
│   └── file-upload-api.yaml
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
app/
├── api/
│   ├── rest/                    # FastAPI REST endpoints
│   │   ├── auth.py             # NEW: OAuth 2.0 endpoints (/auth/token, /auth/refresh, /auth/revoke)
│   │   ├── endpoints.py        # EXISTING: /v1/conversations, /v1/messages, /v1/files
│   │   ├── websocket.py        # NEW: WebSocket endpoint (/ws)
│   │   └── middleware.py       # ENHANCED: JWT validation, rate limiting
│   └── grpc/                    # gRPC services (internal only)
│       ├── message_service.proto
│       └── message_service.py   # NEW: gRPC implementation for worker-to-worker RPC
├── core/
│   ├── domain/                  # Business entities
│   │   ├── message.py
│   │   ├── conversation.py
│   │   ├── user.py
│   │   ├── token.py            # NEW: OAuth 2.0 tokens (access, refresh)
│   │   └── file_upload.py      # ENHANCED: chunked upload metadata
│   ├── ports/                   # Interface definitions
│   │   ├── IMessageStore.py
│   │   ├── IConnector.py
│   │   ├── IOutboxStore.py     # NEW: Outbox pattern interface
│   │   └── IWebSocketManager.py # NEW: WebSocket connection manager interface
│   └── usecases/                # Business logic
│       ├── send_message.py
│       ├── authenticate_user.py # NEW: OAuth 2.0 Client Credentials flow
│       ├── publish_to_outbox.py # NEW: Transactional Outbox logic
│       └── notify_websocket.py  # NEW: Real-time notification logic
├── adapters/
│   ├── connectors/              # Channel-specific adapters
│   │   ├── whatsapp_mock.py    # EXISTING: Mock WhatsApp connector
│   │   └── instagram_mock.py   # EXISTING: Mock Instagram connector
│   ├── repositories/            # Data access
│   │   ├── postgresql/
│   │   │   ├── message_repository.py
│   │   │   ├── token_repository.py     # NEW: access_tokens, refresh_tokens
│   │   │   ├── outbox_repository.py    # NEW: outbox_events CRUD
│   │   │   └── file_repository.py      # ENHANCED: chunk metadata
│   │   └── redis/
│   │       ├── pubsub_adapter.py       # NEW: Redis Pub/Sub for WebSocket fan-out
│   │       ├── rate_limiter.py         # NEW: Redis-based rate limiting
│   │       └── deduplication_cache.py  # NEW: 24h deduplication window
│   └── messaging/               # Kafka producers/consumers
│       ├── kafka_producer.py    # EXISTING: enhanced with idempotency
│       └── kafka_consumer.py    # EXISTING: enhanced with retry logic
├── infrastructure/
│   ├── config/
│   │   └── settings.py          # ENHANCED: OAuth 2.0 JWT secrets, Redis config, observability config
│   ├── monitoring/
│   │   ├── prometheus.py        # NEW: Prometheus metrics instrumentation
│   │   ├── tracing.py           # NEW: OpenTelemetry setup
│   │   └── logging.py           # ENHANCED: Structured JSON logging with trace IDs
│   └── security/
│       ├── jwt_handler.py       # NEW: JWT encode/decode, validation
│       └── oauth2.py            # NEW: OAuth 2.0 Client Credentials implementation
├── workers/
│   ├── outbox_poller.py         # NEW: Poll outbox_events, publish to Kafka
│   ├── message_router.py        # EXISTING: Routes messages to channels
│   ├── file_merge_worker.py     # NEW: Merges file chunks after upload
│   ├── garbage_collector.py     # NEW: Cleans up abandoned chunks after 24h
│   └── connectors/
│       ├── whatsapp_worker.py   # EXISTING: Consumes whatsapp_outgoing topic
│       └── instagram_worker.py  # EXISTING: Consumes instagram_outgoing topic
└── websocket/
    ├── connection_manager.py    # NEW: Track active WebSocket clients
    ├── event_dispatcher.py      # NEW: Dispatch events to subscribed clients
    └── redis_listener.py        # NEW: Listen to Redis Pub/Sub, forward to WebSockets

tests/
├── unit/
│   ├── test_authentication.py   # NEW: OAuth 2.0 flow tests
│   ├── test_outbox_pattern.py   # NEW: Transactional Outbox logic
│   ├── test_websocket.py        # NEW: WebSocket connection/disconnect
│   └── test_file_chunks.py      # NEW: Chunk upload/merge logic
├── integration/
│   ├── test_auth_api.py         # NEW: /auth/token, /auth/refresh endpoints
│   ├── test_websocket_e2e.py    # NEW: End-to-end WebSocket message flow
│   ├── test_outbox_kafka.py     # NEW: Outbox → Kafka → Worker flow
│   └── test_file_upload.py      # ENHANCED: Resumable upload scenarios
├── contract/
│   ├── test_openapi_compliance.py # ENHANCED: Validate new authentication endpoints
│   └── test_websocket_protocol.py # NEW: Validate WebSocket message format
└── e2e/
    ├── test_message_delivery.py  # ENHANCED: Validate at-least-once delivery
    ├── test_failover.py          # NEW: Simulate PostgreSQL/Kafka failures
    └── test_load.py              # NEW: 10M msg/min load test with locust/k6

deployments/
├── kubernetes/
│   ├── api-deployment.yaml      # ENHANCED: HPA, health checks, 3+ replicas
│   ├── worker-deployment.yaml   # ENHANCED: Separate deployments per worker type
│   ├── postgresql-ha.yaml       # NEW: Patroni/Stolon HA cluster
│   ├── kafka-cluster.yaml       # NEW: 3-broker Kafka cluster
│   ├── redis-deployment.yaml    # NEW: Redis for Pub/Sub and caching
│   └── monitoring/
│       ├── prometheus.yaml
│       ├── grafana.yaml
│       └── jaeger.yaml
└── docker-compose.yml           # ENHANCED: Remove container_name for scaling, add Redis
```

**Structure Decision**: The project maintains the existing hexagonal architecture (core/domain, adapters, infrastructure) while adding new components for production readiness:

1. **Authentication Layer** (api/rest/auth.py, core/usecases/authenticate_user.py, infrastructure/security/oauth2.py): Implements OAuth 2.0 Client Credentials flow with JWT tokens. Separates authentication logic from existing API endpoints.

2. **Outbox Pattern** (core/ports/IOutboxStore.py, adapters/repositories/postgresql/outbox_repository.py, workers/outbox_poller.py): Guarantees at-least-once delivery by decoupling database writes from Kafka publishing. The outbox poller is a separate worker to ensure transactional consistency.

3. **WebSocket Layer** (api/rest/websocket.py, websocket/*): Real-time communication via WebSocket endpoint with Redis Pub/Sub for multi-instance fan-out. Connection manager tracks active clients and their subscribed conversations.

4. **Observability Infrastructure** (infrastructure/monitoring/*): Centralized instrumentation for metrics, tracing, and logging. Prometheus metrics, OpenTelemetry tracing, and structured JSON logs are added to all services.

5. **File Upload Workers** (workers/file_merge_worker.py, workers/garbage_collector.py): Background workers handle chunk merging after upload completion and cleanup of abandoned uploads.

6. **High-Availability Deployments** (deployments/kubernetes/*): Production-grade Kubernetes manifests for PostgreSQL HA (Patroni/Stolon), Kafka 3-broker cluster, Redis, and auto-scaling configurations (HPA).

This structure ensures **clean separation of concerns** (authentication, outbox, WebSocket, observability as distinct modules), **independent deployability** (workers can scale independently), and **testability** (each component has corresponding unit/integration tests).

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | All constitution principles satisfied | No violations - no complexity justification required |

**Rationale**: The production-ready evolution strictly adheres to all 7 constitution principles. The OAuth 2.0 Client Credentials flow balances security requirements with implementation simplicity (no user registration flows). The Transactional Outbox pattern is the industry-standard solution for at-least-once delivery guarantees. WebSocket with Redis Pub/Sub is a proven architecture for real-time communication at scale. All design decisions align with constitution requirements without introducing unjustified complexity.
